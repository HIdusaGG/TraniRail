Наша команда работает по такому плану:
Добро пожаловать дорогие разработчики. Тут пройдет мини курс к обучению программированию и к публикации заданий. 
1. Берем самую последнюю версию загружаем себе на компьютер настраиваем и дальше после завершения задания создаем папку с новым апдейтом например была версия
0.0.0 вы создали следующую 0.0.1 формат от 0.0.0 до 99.99.99 если кто-то уже 2 начали делать 1 версию то после работы объеденить новые версии для удобства 
версии можно назвать 0.0.1.1 и 0.0.1.2 так будет понятно где какая часть (заранее создайтепапку с новой версией чтобы было понятно, что делает ли кто-то
обновление или нет, конечная версия 2 и более обнов будет 0.0.1) 

2.Задания будут появляться в текстовом файле tikets и впринципе там будут все наши выполненые планы, в нем нужно также описывать номер обновлнеия например
0.0.0.1 - создание шейдера лампочек ... (дальше после завершения работы пишем)... завершено добавлены шейдеры для лампочек, и пишем добвленые файлы + добавленый 
функционал какие функции кто за что отвечает (если скрипт) например glm::vec3 GetPosTrain() возвращает значение позиции поезда. Затем если обновления сделаны
кто-то напишет 0.0.1 напишет все добавления, объеденит проект, писать по такому же принципу сначало пишем 0.0.1 объединение обновлений... (чтобы не создали 
новые 0.0.0.Х) если вы готовы взяться за работу, но уже объеденяют обновления считайте у вас пока выходной, если кто-то взялся за работу например 0.0.0.1 и
долго не выполняет значить не добавляем добавим в след обновлении и также добавляем метку (просрочено) в файле с tikets после того как просроченое обновление 
доделано и добавлено пишем (просрочено, выполнено)

3.Создание обновления. Вы создаете новый файл с названием отражающее название задания например создание шейдера для лампочек получится light.vs light.fs и другие 
шейдеры (их закидываем в папку shaders)или же задание, добавление логики на перемещение поезда по рельсам TrainPath.cpp (пожже будет подробная инструкция как это
все использовать скрипты будут пока в корневой папки проекта) или же еще тип заданиядобавление нового предмета мороженое, тут уже другая схема переходим в блендер
ДЕЛАЕМ низкополигональную модель нужно сделать так чтобы было минимум вершин, также сходу текстуру, должно получится 3 файла .mtl .obj .png и прочие файлы (с 
ростом движка и новыми функциями их можно будет использовать) их кидаем в соответствующие папки texture и model в модель mtl и onj в текстуры ну текстуры

4. Че и как кодить к каждой вашей строчке добалять комментарий вашего обновления например //0.0.0.1 но это только в общих скриптах по типу main.cpp setting.cpp и 
подобное, если вы создали файл в нем вы просто можете в самом начале написать комментарий с вашим обновлением дальше не писать будет итак понятно что это фулл
ваш код, если скрипт обновляется тогда уже заменяем старый комментарий на новый комментарий обновления ну например где-то в далеком будующем он станет 1.4.87.1,
а теперь к сути вы пишете к примеру новый скрипт что вы делает создает к примеру TrainPath.cpp в нем пишете
```
//0.0.0.1
distance = 0;
//функционал
float GetTrainDistance()
{
  return distance;
}
void TrainDistance(float speed, float deltaTime)
{
  distance += speed * deltaTime;
}
```
после нужно добавит скрипт в настройки делается это так переходим в setting.cpp затем добавляем
'''
#include "TrainPath.cpp" //0.0.0.1
'''
затем где-то в main.cpp добавляем функционал
'''
while (true)
  {
    //код
    TrainDistance(speed, deltaTime); //0.0.0.1 (доп коментарий можно) передаем данные скорости и реального времени в наш скрипт, а именно в функцию TrainDistance 
    GetTrainDistance(); //0.0.0.1 получаем данные о позиции поезда
  }
'''
В случае с добавлением шейдера аналогично все расписываем в документации движка можно будет также посмотреть, что куда и как идет, так как движок снова пишется с 
0 пока что будет пустоосновную часть я верну
5. Обучение
Начнем с базы
Переменые
Существуют множество перменных рассмотрим int, std::string, char, bool. 
1 int это переменая целых чисел тоесть она хранит в себе числа 1, 2, 3 и тп           использовать  int cat = 3;
2 float эта переменая хранит в себе ПИздец тоесть 3.14 и подобные числа 69.1488, 1.5  использовать  float pi = 3,14;
3 std::string хранит в себе значение текста тоесть "хело бич айм гей сергей"          использовать  std::string text = "hello mazafaka";
4 bool грубо говоря хранит 1 или 0 тоесть true или false                              использовать  bool active = true;

Циклы
if(a>b) 
{
  //code
}
это условный оператор он сравнивает больше а чем б или нет он имеет в себе доп функции ( a > 1 || b > 1) || это знак ИЛИ тоесть или а больше 1 или б больше 1
( a < b && b > a) && это знак И тоесть 2 выражение должно быть правлой !(a > 1) ! означает НЕ тоесть а не должно быть больше 1 также можно использовать 
арифметические выражения по типу ((a + i) == j) также знаки >< сравнить, >= <= больше равно меньше равно, == равно, ну и повторюсь знаик выше ! не, && и,
|| или. Также существует оператор else if Он обязательно идет после if по сути если 1 не выполнилось то выполняется 2 в нем также можно использовать все 
выражения, дальше идет else Это коонец операторов он нужен если надо показать, что никакой вариант не подошел и выглядит все так
if(a == 1)
{
 //code
}
else 
{
 //code
}
Или же можнои спользовать просто 
if(a == 1)
{
 //code
}
if(a == 2)
{
 //code
}
if(a == 3)
{
 //code
}
также если нужно большая строгость к выполнению 
if(a == 1)
{
 //code
}
else if (a == 2)
{
 //code
}
else
{
 //code
}

Циклы, одна из важных частей существуют множество циклов рассмотрим 2 while И for
while как как if  выполняется пока верно выражение например
while (true) цикл всегда выполняется, но также из него можно выйти при помощи break; 
while (i < 10) цикл выполняется пока i не станет больше 9
for тут куда интереснее тут своя схема
for (;;) бесконечный цикл таке можно выйти при помощи break; 
for (int i = 0; i < 20; i++) тут цикл выполнится 20 раз 1 это переменая, 2 это как while условие перменой, и 3 это операция с этой переменой, по сути тут цикл 
гарантировано выполнится  20 раз если кончено не будет преград по типу break;

Также у цикла for есть темная сторона к примеру 
for(auto& obj : objects) тоесть тут мы создаем переменную auto& obj (auto& принемает в данном случае структуру массив) obj это название переменой дальше идет
: objects это наш массив который мы читаем от самого начала до конца записываая в obj и  также есть штука как const она делает наш цикл недоступный для 
правок в массив, на примере можно взять for (int i = 0; i < 20; i++) тут мы как бы создаем i читаем ее и пополняем на еденицу после завершение теперь 
наш индекс вместо 0 стал 1 тоесть значение переменой i = 1  вместо i = 0 таеже и с for(auto& obj : objects) мы читаем objects затем начиная с 0 индекса 
записываем в obj тоесть obj = objects[0] (чтобы понятнее было), затем после выполнения цикла 1 раз мы читаем дальше и если дальше есть и цикл находит то 
начинается след цикл с индексом 1 тоесть переменная obj храниет в себе данные из масива objects по индексу 1 тоесть  obj = objects[1]

Функции существуют множество различных функций расмотрим просто блок кода и функции с возвращением значением RETURN тут я покажу как и зачем он нужен сперва 
рассмотрим void обычная функция
void MyTrain() { /* code */} мы создали функцию MyTrain отлично ее можно вызвать в другой части кода занимая 1 строчку кода при помощи MyTrain();
void MyTrain(int countTrain) { print(countTrain); } (я пишу в 1 строчку для удобства ибо функция маленькая) тут мы создали нашу функцию MyTRain,
которая обязательно должна принемать значение
количества поезов тоесть countTrain вызвать ее в другом коде можно при помощи MyTrain(9); согласно коду она выведет в консоль число 9 тоесть у нас 9 поездов

int GetTrain() { /* code и обязательно return*/ return count; } тут мысоздали функцию, которая возвращает значение количество чего либо в данном случае 
поездов тоесть в коде может быть как
int a = GetTrain(); мы присвоили значение поездов переменой a

std::string GetTextTrain(int trainNumber) {
  return "Поезд №" + std::to_string(trainNumber) + " отправился со станции!";
}
как использовать? print(120); (выведет Поезд №120 отправился со станции) 
ИТАК ВАЖНЫЙ ВОПРОС что такое std::to_string? это функция библиотеки, которая конвертирует переменную в определенный формат, в данном случае
обязательно int конвертировать в string при помощи to_string (можно конвертировать все в текст), std:: является как бы ссылкой на вещи из библиоткеи
также есть std::stoi, std::stof преабразует текст в инт или флоат (доубле не берем он вам не нужен будет как показывает практика)
